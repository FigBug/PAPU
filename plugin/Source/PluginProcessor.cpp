/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

const char* PAPUAudioProcessor::paramPulse1Sweep      = "sweep1";
const char* PAPUAudioProcessor::paramPulse1Shift      = "shift1";
const char* PAPUAudioProcessor::paramPulse1Duty       = "shiftDuty";
const char* PAPUAudioProcessor::paramPulse1A          = "shiftA";
const char* PAPUAudioProcessor::paramPulse1R          = "shiftR";
const char* PAPUAudioProcessor::paramPulse1OL         = "shiftOL";
const char* PAPUAudioProcessor::paramPulse1OR         = "shiftOR";
const char* PAPUAudioProcessor::paramOutputL          = "outputL";
const char* PAPUAudioProcessor::paramOutputR          = "outputR";

//==============================================================================
String percentTextFunction (const slParameter& p, float v)
{
    return String::formatted("%.0f%%", v / p.getUserRangeEnd() * 100);
}

String typeTextFunction (const slParameter& p, float v)
{
    return v > 0.0f ? "White" : "Periodic";
}


String speedTextFunction (const slParameter& p, float v)
{
    switch (int (v))
    {
        case 0: return "Fast";
        case 1: return "Medium";
        case 2: return "Slow";
        case 3: return "Tone 2";
    }
    return "";
}

//==============================================================================
PAPUAudioProcessor::PAPUAudioProcessor()
{
    addPluginParameter (new slParameter (paramPulse1Sweep,     "Pulse 1 Sweep",      "Sweep 1",     "", -15.0f, 15.0f,  1.0f, 0.0f, 1.0f));
    addPluginParameter (new slParameter (paramPulse1Shift,     "Pulse 1 Shift",      "Shift 1",     "",   0.0f, 15.0f,  1.0f, 0.0f, 1.0f));
    addPluginParameter (new slParameter (paramPulse1Duty,      "Pulse 1 Duty",       "Duty 1",      "",   0.0f, 3.0f,   1.0f, 0.0f, 1.0f));
    addPluginParameter (new slParameter (paramPulse1A,         "Pulse 1 A",          "A 1",         "",   0.0f, 15.0f,  1.0f, 7.0f, 1.0f));
    addPluginParameter (new slParameter (paramPulse1R,         "Pulse 1 R",          "R 1",         "",   0.0f, 15.0f,  1.0f, 7.0f, 1.0f));
    addPluginParameter (new slParameter (paramPulse1OL,        "Pulse 1 OL",         "OL 1",        "",   0.0f, 1.0f,   1.0f, 1.0f, 1.0f));
    addPluginParameter (new slParameter (paramPulse1OR,        "Pulse 1 OR",         "OR 1",        "",   0.0f, 1.0f,   1.0f, 1.0f, 1.0f));
    addPluginParameter (new slParameter (paramOutputL,         "Output L",           "Out L",       "",   0.0f, 15.0f,  1.0f, 15.0f, 1.0f));
    addPluginParameter (new slParameter (paramOutputR,         "Output R",           "Out R",       "",   0.0f, 15.0f,  1.0f, 15.0f, 1.0f));
}

PAPUAudioProcessor::~PAPUAudioProcessor()
{
}

//==============================================================================
void PAPUAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    outputSmoothed.reset (sampleRate, 0.05);

    apu.output (buf.center(), buf.left(), buf.right());
    buf.clock_rate (4194304);
    buf.set_sample_rate (sampleRate);
    
    apu.write_register (clock(), 0xff26, 0x8f);
}

void PAPUAudioProcessor::releaseResources()
{
}

void PAPUAudioProcessor::runUntil (int& done, AudioSampleBuffer& buffer, int pos)
{
    time = 0;
    int todo = jmin (pos, buffer.getNumSamples()) - done;

    while (todo > 0)
    {
        if (buf.samples_avail() > 0)
        {
            blip_sample_t out[1024];
            
            int count = buf.read_samples (out, jmin (todo, 1024 / 2, (int) buf.samples_avail()));
        
            float* data0 = buffer.getWritePointer (0, done);
            float* data1 = buffer.getWritePointer (1, done);
            
            for (int i = 0; i < count; i++)
            {
                data0[i] = out[i * 2 + 0] / 32768.0f;
                data1[i] = out[i * 2 + 1] / 32768.0f;
            }
            
            done += count;
            todo -= count;
        }
        else
        {
            apu.end_frame (1024);
            buf.end_frame (1024);
        }
    }
}

void PAPUAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midi)
{
    uint16_t reg;
    
    reg = 0x88 | (parameterIntValue (paramOutputL) << 4) | parameterIntValue (paramOutputR);
    if (reg != last24)
        apu.write_register(clock(), 0xff24, last24 = reg);
    
    reg = (parameterIntValue (paramPulse1OL) ? 0x10 : 0x00) |
          (parameterIntValue (paramPulse1OR) ? 0x01 : 0x00);
    
    if (reg != last25)
        apu.write_register(clock(), 0xff25, last25 = reg);
    
    int done = 0;
    runUntil (done, buffer, 0);
    
    int pos = 0;
    MidiMessage msg;
    MidiBuffer::Iterator itr (midi);
    while (itr.getNextEvent (msg, pos))
    {
        runUntil (done, buffer, pos);
        
        if (msg.isNoteOn())
        {
            noteQueue.add (msg.getNoteNumber());
            velocity = msg.getVelocity();
        }
        else if (msg.isNoteOff())
        {
            noteQueue.removeFirstMatchingValue (msg.getNoteNumber());
            
        }
        else if (msg.isAllNotesOff())
        {
            noteQueue.clear();
        }
        
        const int curNote = noteQueue.size() > 0 ? noteQueue.getLast() : -1;
        
        if (curNote != lastNote)
        {
            int v = curNote == -1 ? 0 : velocity;
            
            // Noise
            if (curNote != -1)
            {
                uint8_t sweep = std::abs (parameterIntValue (paramPulse1Sweep));
                uint8_t neg   = parameterIntValue (paramPulse1Sweep) < 0;
                uint8_t shift = parameterIntValue (paramPulse1Shift);
                
                apu.write_register (clock(), 0xff10, (sweep << 4) | ((neg ? 1 : 0) << 3) | shift);
                apu.write_register (clock(), 0xff11, (parameterIntValue (paramPulse1Duty) << 6));
                apu.write_register (clock(), 0xff12, 0x70 | (0 << 3) | parameterIntValue (paramPulse1A));
                
                uint16_t period = 2048 - 131072 / getMidiNoteInHertz (curNote);
                apu.write_register (clock(), 0xff13, period & 0xff);
                apu.write_register (clock(), 0xff14, 0x80 | ((period >> 8) & 0x3));
            }
            else
            {
                apu.write_register (clock(), 0xff12, 0x70 | (1 << 3) | parameterIntValue (paramPulse1R));
            }
            
            lastNote = curNote;
        }
    }
    
    runUntil (done, buffer, buffer.getNumSamples());
    
    float* data = buffer.getWritePointer (0);
    
    if (editor)
        editor->scope.addSamples (data, buffer.getNumSamples());
}

//==============================================================================
bool PAPUAudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* PAPUAudioProcessor::createEditor()
{
    editor = new PAPUAudioProcessorEditor (*this);
    return editor;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new PAPUAudioProcessor();
}
